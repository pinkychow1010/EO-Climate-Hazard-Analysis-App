// released under MIT License Copyright Â© 2023 Ka Hei Chow

// ################################################## //
// ### World Bank Intra-Urban Data Explorer Tool #### //
// ################################################## //

// This script provides export functions for all available layers,
// summarized in layer_dict dict

// It is used to download multiple regional rasters in customised resolution
// to facilitate EO-based intra-urban analysis

// import module
var basemap = require('users/pinkychow1010/WB_IntraUrban:basemap_resources');
var palettes = require('users/gena/packages:palettes');
var helper = require('users/pinkychow1010/GEE:WorldBank/helper');

// dictionary for default resolution
exports.resolution_dict = {
  'Land Use Cover': 10,
  'Population Count': 38,
  'Urban Density': 2000,
  'Summer Day Temperature': 1000,
  'Summer Night Temperature': 1000
};

// dictionary for filename definitions
exports.filename_dict = {
  'Land Use Cover': 'ESA-WorldCover-2020',
  'Population Count': 'Population-GPW-2015',
  'Urban Density': 'ESA-WorldCover-derived-urban-density',
  'Summer Day Temperature': 'MODIS-LST-day',
  'Summer Night Temperature': 'MODIS-LST-night'
};

// dictionary for resampling algorithms
exports.reducer_dict = {
  'Land Use Cover': ee.Reducer.mode(), // retain discrete class
  'Population Count': ee.Reducer.sum(), // population count per pixel
  'Urban Density': ee.Reducer.mean(), // ratio
  'Summer Day Temperature': ee.Reducer.median(), // median to prevent influence from outliners
  'Summer Night Temperature': ee.Reducer.median() // median to prevent influence from outliners
};

// dictionary for action labels and corresponding functions (call map layer display + return layer for export)
exports.layer_dict = {
  'Land Use Cover': export_landuse,
  'Population Count': export_population,
  'Urban Density': export_urban_density,
  'Summer Day Temperature': export_summer_lst,
  'Summer Night Temperature': export_summer_lst_night
};

// define function for Summer Temperature
// exports.export_summer_lst_night = 
function export_summer_lst_night(aoi) {
  
  // calculate geometry of vector layer
  var bbox = aoi.geometry();
  
  // determine location in south / north hemisphere (different summer months)
  var centroid = bbox.centroid();
  var listCoords = ee.Array.cat(centroid.coordinates(), 0); 
  var yCoords = ee.List(listCoords).getInfo()[1];
  
  // south/ north
  var south = ee.Number(yCoords).lt(0);
  var shift = south.multiply(6).getInfo();
  
  // evaluation year
  var start_year = ee.Date("2020-01-01");
  var end_year = ee.Date("2021-01-01");
  
  // filter dataset to evaluation year
  var yearFilter = ee.Filter.date(
    start_year.advance(-1, "year"), 
    end_year.advance(1, "year")
    );
  
  // get summer months depends on location
  var summerFilter = ee.Filter.calendarRange(5+shift, 9-shift, "month");

  var lst = ee.ImageCollection("MODIS/061/MOD11A2")
    //.map(maskClouds) // to be done: add MODIS cloud masking 
    .select("LST_Night_1km") // day time temperature
    .filter(yearFilter) // filter year
    .filter(summerFilter) // filter season
    .median() // get median
    .multiply(0.02) // apply scale factor
    .subtract(272.15) // apply offset
    .clip(bbox); // limit bounds
  
  // visualization format
  var vis = {
    min: 20.0,
    max: 40.0,
    palette: ['blue', 'white', 'red'],
  };
  
  // add layer for land surface temperature
  Map.addLayer(lst, vis, 'MODIS LST Night 2020');
  Map.centerObject(bbox, 8);
  
  // add legend to raster layer
  var legend = helper.add_colorbar(vis, "LST Night");
  Map.add(legend);
  
  // for some reason, the original projection altered after temporal filtering
  // this line is necessary to set back valid projection for the output layer
  var ref = ee.ImageCollection("MODIS/061/MOD11A2").first().projection();
  
  return lst.setDefaultProjection(ref);
}

/**
 * Calculate summer land surface temperature: export summer average temperature to interactive dashboard.
 * 
 * This function is used to construct a MODIS-based LST gridded dataset based on location inputs from users.
 * 
 * @author Ka Hei Chow.
 *
 * @see  helper.add_colormap
 * @link 'users/pinkychow1010/GEE:WorldBank/helper'
 * @global
 *
 * @fires   add LST raster layer
 * @listens select area of interest
 *
 * @param {ee.Geometry.Polygon}   vector        A vector layer which consists of a single polygon (admin boundary).
 * 
 * @return {ee.Image} Single LST data layer bounds by selected admin 2 boundary.
 *
 */
// exports.export_summer_lst = 
function export_summer_lst(aoi) {
  
  // calculate geometry of vector layer
  var bbox = aoi.geometry();
  
  // determine location in south / north hemisphere (different summer months)
  var centroid = bbox.centroid();
  var listCoords = ee.Array.cat(centroid.coordinates(), 0); 
  var yCoords = ee.List(listCoords).getInfo()[1];
  
  // south/ north
  var south = ee.Number(yCoords).lt(0);
  var shift = south.multiply(6).getInfo();
  
  // evaluation year
  var start_year = ee.Date("2020-01-01");
  var end_year = ee.Date("2021-01-01");
  
  // filter dataset to evaluation year
  var yearFilter = ee.Filter.date(
    start_year.advance(-1, "year"), 
    end_year.advance(1, "year")
    );
  
  // get summer months depends on location
  var summerFilter = ee.Filter.calendarRange(5+shift, 9-shift, "month");

  var lst = ee.ImageCollection("MODIS/061/MOD11A2")
    //.map(maskClouds) // to be done: add MODIS cloud masking 
    .select("LST_Day_1km") // day time temperature
    .filter(yearFilter) // filter year
    .filter(summerFilter) // filter season
    .median() // get median
    .multiply(0.02) // apply scale factor
    .subtract(272.15) // apply offset
    .clip(bbox); // limit bounds
  
  // visualization format
  var vis = {
    min: 20.0,
    max: 40.0,
    palette: ['blue', 'white', 'red'],
  };
  
  // add layer for land surface temperature
  Map.addLayer(lst, vis, 'MODIS LST Day 2020');
  Map.centerObject(bbox, 8);
  
  // add legend to raster layer
  var legend = helper.add_colorbar(vis, "LST Day");
  Map.add(legend);
  
  // for some reason, the original projection altered after temporal filtering
  // this line is necessary to set back valid projection for the output layer
  var ref = ee.ImageCollection("MODIS/061/MOD11A2").first().projection();
  
  return lst.setDefaultProjection(ref);
}

// define function for Population Count

/**
 * World Population: export population density layer to interactive dashboard.
 * 
 * This function is used to construct a population count gridded dataset based on location inputs from users.
 * 
 * @author Ka Hei Chow.
 *
 * @see  helper.add_colormap
 * @link 'users/pinkychow1010/GEE:WorldBank/helper'
 * @global
 *
 * @fires   add population density raster layer
 * @listens select area of interest
 *
 * @param {ee.Geometry.Polygon}   vector        A vector layer which consists of a single polygon (admin boundary).
 * 
 * @return {ee.Image} Single population count data layer bounds by selected admin 2 boundary.
 *
 */
// exports.export_population = 
function export_population(aoi) {
  
  // compute vector boundary
  var bbox = aoi.geometry();
  
  // get population dataset (GHSL 2015)
  var dataset = ee.ImageCollection('JRC/GHSL/P2016/POP_GPW_GLOBE_V1')
                  .filter(ee.Filter.date('2015-01-01', '2015-12-31')).first();
  var pop = dataset.select('population_count').clip(bbox); // limit bounds
  
  // visualization format
  var vis = {
    min: 0.0,
    max: 200.0,
    palette: ['060606', '337663', '337663', 'ffffff'],
  };
  
  // add layer for population
  Map.addLayer(pop, vis, 'GSHL Population 2015');
  Map.centerObject(bbox, 8);
  
  // add legend to raster layer
  var legend = helper.add_colorbar(vis, "Population");
  Map.add(legend);

  return pop;
}
  

// define function for ESA world cover 2020

/**
 * Land Use Cover 2020: export land use cover (LULC) layer to interactive dashboard.
 * 
 * This function is used to construct a land use cover gridded dataset based on location inputs from users.
 * 
 * @author Ka Hei Chow.
 *
 * @see  helper.add_colormap
 * @link 'users/pinkychow1010/GEE:WorldBank/helper'
 * @global
 *
 * @fires   add LULC raster layer
 * @listens select area of interest
 *
 * @param {ee.Geometry.Polygon}   vector        A vector layer which consists of a single polygon (admin boundary).
 * 
 * @return {ee.Image} Single land use data layer bounds by selected admin 2 boundary.
 *
 */
// exports.export_landuse = 
function export_landuse(aoi) {
  
  // calculate boundary
  var bbox = aoi.geometry();
  
  // get land use cover dataset for boundary
  var lulc = ee.ImageCollection('ESA/WorldCover/v200')
  .first()
  .clip(bbox);

  // add LULC raster layer on map
  Map.addLayer(lulc, {}, 'Land Use Cover 2020');
  Map.centerObject(bbox, 8);
  
  // hard code class and color code for world cover dataset
  var landcoverPalette = ee.List(['006400','ffbb22','ffff4c','f096ff','fa0000','b4b4b4','f0f0f0','0064c8','0096a0','00cf75','fae6a0']);

  var newNames = ['Tree cover','Shrubland','Grassland','Cropland',
  'Built-up','Bare / sparse vegetation','Snow and ice','Permanent water bodies',
  'Herbaceous wetland','Mangroves','Moss and lichen'];
  
  // var names = ee.List(lulc.get('Map_class_names'));
  // var landcoverPalette = ee.List(lulc.get('Map_class_palette'));
  // var landcoverVisualization= ee.Dictionary({palette: landcoverPalette, min: 0, max: 44, format: 'png'});
  
  // Create the panel for the legend items.
  var legend = ui.Panel({
    style: {
      position: 'bottom-right',
      padding: '8px 15px'
    }
  });
  
  // Create and add the legend title.
  var legendTitle = ui.Label({
    value: 'Land Cover',
    style: {
      fontWeight: 'bold',
      fontSize: '18px',
      margin: '0 0 4px 0',
      padding: '0'
    }
  });
  legend.add(legendTitle);
  
  // Creates and styles 1 row of the legend.
  var makeRow = function(color, name) {
    // Create the label that is actually the colored box.
    var color = color.getInfo();
    var colorBox = ui.Label({
      style: {
        backgroundColor: '#' + color,
        // Use padding to give the box height and width.
        padding: '8px',
        margin: '0 0 4px 0'
      }
    });
  
    // Create the label filled with the description text.
    var description = ui.Label({
      value: name,
      style: {margin: '0 0 4px 6px'}
    });
  
    return ui.Panel({
      widgets: [colorBox, description],
      layout: ui.Panel.Layout.Flow('horizontal')
    });
  };
  
  // // use getInfo to make the names client-side
  // var newNames = names.getInfo();
  
  // add legend row by row
  for (var i = 0; i < 11; i++) {
      legend.add(makeRow(landcoverPalette.get(i), newNames[i]));
  }
  Map.add(legend);
  
  return lulc;
}

// define function for extract dense urban areas
// this script is used to extract urban areas (larger than 20%) and estimate urban density 

/**
 * Urban Density: export urban density layer to interactive dashboard.
 * 
 * This function is used to construct a urban density gridded dataset based on location inputs from users, 
 * masked by urban regions (higher than 20% of areas within 5 km-radius circle).
 * 
 * @author Ka Hei Chow.
 *
 * @see  helper.add_colormap
 * @link 'users/pinkychow1010/GEE:WorldBank/helper'
 * @global
 *
 * @fires   add urban density raster layer
 * @listens select area of interest
 *
 * @param {ee.Geometry.Polygon}   vector        A vector layer which consists of a single polygon (admin boundary).
 * 
 * @return {ee.Image} Single urban density data layer bounds by selected admin 2 boundary.
 *
 */
// exports.export_urban_density = 
function export_urban_density(aoi) {
  
  // compute boundary
  var bbox = aoi.geometry();
  
  // get land use cover
  var lulc = ee.ImageCollection('ESA/WorldCover/v200')
  .first()
  .clip(bbox);
  
  // extract urban land use
  var urban_mask = lulc.eq(50);
  
  // calculate urban density within 5km radius (circle)
  var reduceNeighborhood = urban_mask.reduceNeighborhood(
    ee.Reducer.mean(), 
    ee.Kernel.circle(5000, 'meters')
  ).multiply(100).toByte();
  
  // visualization params
  var palette = palettes.misc.tol_rainbow[7];
  var vis = {min: 20, max: 80, palette: palette};
  
  // focus on dense areas, masked rural areas (< 20%)
  var urban_threshold = reduceNeighborhood.gt(20);
  var reduceNeighborhoodMasked = reduceNeighborhood.updateMask(urban_threshold);
  
  // add urban density layer to map
  Map.addLayer(reduceNeighborhoodMasked, vis, 'Urban Density');
  Map.centerObject(bbox, 8);
  
  // add legend
  var legend = helper.add_colorbar(vis, "Urban Density");
  Map.add(legend);
  
  return reduceNeighborhoodMasked;
}


exports.addWelcomePanel = function addWelcomePanel() {
  
  // set style for elements
  var msg_style = {
    whiteSpace: 'pre', 
    textAlign: 'center', 
    padding: '0px 50px 50px 50px',
    width: '500px',
    color: 'grey',
    fontSize: '15px'
  };
  
  var hd_style = {
      whiteSpace: 'pre', 
      textAlign: 'center', 
      padding: '50px 50px 0px 50px',
      width: '500px',
      fontSize: '26px', 
      fontWeight:'bold'
    };
  
  var button_style = {
    padding:'0% 42.5% 20% 42.5%',
    position: 'top-center'
  };
  
  var page_style = {border: '5px solid #c9c9c9', position: 'top-center'};
  
  // Page 1
  var instructionMessage = ui.Label(
  'To start download, select the dataset \nand your area of interest (ADMIN Level 2).\
  \nYou can download the layer in desired resolution. \n \
  As data is computed on-the-fly, \nloading might take a while.'
  , msg_style);
    
  var heading = ui.Label('\n\n\nðŸ‘‹ Welcome!', hd_style);
  
  // Page 2
  var instructionMessage_p2 = ui.Label(
    'Check out all available datasets:\
    \n\nðŸŒ¾ Land Use Cover âžœ ESA World Cover 2020\
    \nðŸ‘¥ Population Count âžœ Global Human Settlement Population Grid 2015\
    \nðŸŒƒ Urban Density âžœ Urban ratio derived from World Cover\
    \nðŸŒž Summer Day Temperature âžœ MODIS day Land Surface Temperature\
    \nðŸŒ™ Summer Night Temperature âžœ MODIS night Land Surface Temperature'
    , msg_style);
    
  instructionMessage_p2.style().set({fontSize: '13.5px'});
  
  var heading_p2 = ui.Label('\n\nðŸ‘‹ Welcome!', hd_style);
  
  // Page 3
  var instructionMessage_p3 = ui.Label('You can download documentation below\n to view more layer details: â¬‡ï¸', msg_style);
    
  instructionMessage_p3.style().set({padding: '0px 50px 20px 50px'});
  
  var heading_p3 = ui.Label('\n\nðŸ‘‹ Welcome!', hd_style);
  
  // Welcome panel first page
  var nextButton = ui.Button('Next', p2);
  nextButton.style().set(button_style);
  
  function hide(widget) {
    widget.style().set({shown: false});
  }
  
  function p2() {
    hide(instructionPanel_p1);
    Map.add(instructionPanel_p2);
  }
  
  // Welcome panel second page
  var nextButton_p3 = ui.Button('Next', p3);
  nextButton_p3.style().set(button_style);
  
  function p3() {
    hide(instructionPanel_p2);
    Map.add(instructionPanel_p3);
  }
  
  // Welcome panel third page
  var okButton = ui.Button('Get Started', ok);
  okButton.style().set(button_style);
  
  function ok() {hide(instructionPanel_p3)}
  
  // Documentation session
  // button to export, will fire download url when clicked
  var table = ee.FeatureCollection("projects/ee-pinkychow1010/assets/intraurban_layer_documentation");
  var docButton = ui.Label({value: 'ðŸ“„ï¸ Download Documentation', targetUrl: table.getDownloadURL()});
  // downloadDoc);
  docButton.style().set({
    padding:'0% 25% 15% 25%',
    position: 'top-center'
  });

  // construct pages
  var instructionPanel_p1 = ui.Panel([heading, instructionMessage, nextButton]);
  var instructionPanel_p2 = ui.Panel([heading_p2, instructionMessage_p2, nextButton_p3]);
  var instructionPanel_p3 = ui.Panel([heading_p3, instructionMessage_p3, docButton, okButton]);

  instructionPanel_p1.style().set(page_style);
  instructionPanel_p2.style().set(page_style);
  instructionPanel_p3.style().set(page_style);

  Map.add(instructionPanel_p1);
};
